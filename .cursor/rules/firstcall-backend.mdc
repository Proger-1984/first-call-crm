# First Call API - Backend Project Rules

## Обзор проекта

First Call API — REST API сервис для CRM системы управления подписками на недвижимость. Система обеспечивает авторизацию через Telegram, управление подписками, парсинг объявлений и автоматические уведомления через Telegram Bot.

---

## Технологический стек

### Основные технологии
- **PHP**: 8.3+ со строгой типизацией
- **Framework**: Slim 4 с PHP-DI (Dependency Injection)
- **ORM**: Illuminate Database (Eloquent ORM) из Laravel
- **База данных**: PostgreSQL 15 + PostGIS для геолокации
- **Авторизация**: JWT (firebase/php-jwt) — access + refresh токены
- **Логирование**: Monolog 3.x
- **HTTP**: PSR-7 (slim/psr7, slim/http)
- **Валидация**: Respect/Validation 2.x
- **HTTP клиент**: GuzzleHTTP 7.x

### Инфраструктура
- Docker + Docker Compose
- Nginx (reverse proxy + SSL termination)
- PHP-FPM (web requests)
- PHP-CLI + Supervisor (cron jobs, background tasks)

---

## Архитектура приложения

```
┌─────────────────────────────────────────┐
│         HTTP Request (Nginx)            │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│          Middleware Layer               │
│  - CORS                                 │
│  - JSON Body Parser                     │
│  - Auth (JWT verification)              │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         Controller Layer                │
│  - Валидация запросов                   │
│  - Формирование ответов                 │
│  - Делегирование в сервисы              │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│          Service Layer                  │
│  - Бизнес-логика                        │
│  - Интеграции (Telegram)                │
│  - Логирование                          │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│           Model Layer                   │
│  - Eloquent модели                      │
│  - Связи (Relations)                    │
│  - Аксессоры/мутаторы                   │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│      PostgreSQL + PostGIS               │
└─────────────────────────────────────────┘
```

---

## Структура проекта

```
├── bootstrap/          # Инициализация приложения
│   ├── app.php        # Загрузка .env, конфигов, Eloquent
│   ├── container.php  # DI контейнер (регистрация сервисов)
│   ├── middleware.php # Глобальные middleware
│   └── routes.php     # Загрузка маршрутов
├── config/            # Конфигурационные файлы
│   ├── app.php        # Настройки приложения
│   ├── jwt.php        # JWT настройки (секреты, TTL)
│   └── telegram.php   # Telegram Bot API
├── db/migrations/     # Миграции базы данных
├── docs/              # Документация
│   ├── api/           # OpenAPI спецификация
│   │   ├── openapi.yaml
│   │   └── redoc.html
│   ├── ARCHITECTURE.md
│   ├── DATABASE.md
│   └── API-QUICK-REFERENCE.md
├── logs/              # Логи приложения
├── public/            # Точка входа
│   └── index.php
├── routes/            # Определение маршрутов API
│   └── routes.php
├── src/               # Исходный код
│   ├── Commands/      # Консольные команды (парсеры, cron)
│   ├── Controllers/   # HTTP контроллеры
│   ├── Middleware/    # PSR-15 middleware
│   ├── Models/        # Eloquent модели
│   ├── Services/      # Сервисный слой (бизнес-логика)
│   ├── Traits/        # Переиспользуемые трейты
│   └── Utils/         # Утилиты (генераторы, хелперы)
├── storage/           # Хранилище файлов
│   └── downloads/     # Файлы для скачивания (APK)
└── vendor/            # Composer зависимости
```

---

## Правила написания кода

### 1. Общие требования PHP

```php
<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Traits\ResponseTrait;
use App\Services\ExampleService;
use Exception;
use Psr\Container\ContainerInterface;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
```

**Обязательно:**
- `declare(strict_types=1);` в начале КАЖДОГО PHP файла
- Строгая типизация параметров и возвращаемых значений
- Namespace `App\` для всех классов в `src/`
- Импортировать ВСЕ используемые классы через `use`
- PHPDoc для публичных методов и свойств
- НЕ использовать лишние фигурные скобки в строковой интерполяции (Unnecessary curly braces). Вместо `"{$var}"` писать `"$var"`, кроме случаев когда скобки необходимы для доступа к свойствам/методам объекта или элементам массива

### 2. Контроллеры

**Расположение:** `src/Controllers/`

**Структура контроллера:**
```php
<?php

declare(strict_types=1);

namespace App\Controllers;

use App\Traits\ResponseTrait;
use App\Services\ExampleService;
use Exception;
use Psr\Container\ContainerExceptionInterface;
use Psr\Container\ContainerInterface;
use Psr\Container\NotFoundExceptionInterface;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;

class ExampleController
{
    use ResponseTrait;

    private ExampleService $exampleService;

    /**
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     */
    public function __construct(ContainerInterface $container)
    {
        $this->exampleService = $container->get(ExampleService::class);
    }

    /**
     * Описание метода на русском языке
     */
    public function actionName(Request $request, Response $response): Response
    {
        try {
            // 1. Получаем userId из AuthMiddleware
            $userId = $request->getAttribute('userId');
            
            // 2. Получаем и валидируем данные
            $data = $request->getParsedBody();
            $errors = $this->validateData($data);
            if ($errors !== null) {
                return $this->respondWithError($response, $errors, 'validation_error', 400);
            }

            // 3. Делегируем бизнес-логику в сервис
            $result = $this->exampleService->doSomething($userId, $data);

            // 4. Возвращаем успешный ответ
            return $this->respondWithData($response, [
                'code' => 200,
                'status' => 'success',
                'message' => 'Операция выполнена успешно',
                'data' => $result
            ], 200);

        } catch (Exception $e) {
            return $this->respondWithError($response, $e->getMessage(), null, 500);
        }
    }

    /**
     * Валидация данных запроса
     * 
     * @param array $data Данные для валидации
     * @return string|null Сообщение об ошибке или null
     */
    private function validateData(array $data): string|null
    {
        if (!isset($data['required_field'])) {
            return 'Отсутствует обязательное поле required_field';
        }
        
        if (!is_bool($data['boolean_field'] ?? null)) {
            return 'Поле boolean_field должно быть boolean';
        }
        
        return null;
    }
}
```

**Правила контроллеров:**
- ВСЕГДА использовать `ResponseTrait` для унифицированных ответов
- Инжектировать зависимости через `ContainerInterface` в конструкторе
- Валидация через приватные методы `validate*Data()` — возвращают `string|null`
- Бизнес-логика ВСЕГДА выносится в сервисы
- Оборачивать код в `try-catch`
- Получать `userId` из `$request->getAttribute('userId')` (устанавливается AuthMiddleware)
- Получать `userRole` из `$request->getAttribute('userRole')` для проверки прав

### 3. Формат ответов API

**Успешный ответ:**
```php
return $this->respondWithData($response, [
    'code' => 200,
    'status' => 'success',
    'message' => 'Операция выполнена успешно',  // опционально
    'data' => $result                            // опционально
], 200);
```

**Ответ с ошибкой:**
```php
return $this->respondWithError(
    $response,
    'Текст ошибки для пользователя',  // message (человекочитаемый)
    'error_code',                      // error (машинночитаемый код)
    400                                // HTTP status code
);
```

**JSON формат ответа:**
```json
// Успех
{
  "code": 200,
  "status": "success",
  "message": "Настройки успешно обновлены",
  "data": { ... }
}

// Ошибка
{
  "code": 400,
  "status": "error",
  "message": "Неверный формат запроса. Отсутствует поле name",
  "error": "validation_error"
}
```

**Стандартные коды ошибок:**
- `validation_error` — ошибка валидации (400, 422)
- `not_found` — ресурс не найден (404)
- `access_denied` — доступ запрещён (403)
- `invalid_credentials` — неверные учётные данные (401)
- `token_not_found` — токен не найден (401)
- `invalid_token` — невалидный токен (401)
- `token_expired` — токен истёк (401)
- `invalid_token_type` — неверный тип токена (401)
- `internal_error` — внутренняя ошибка (500)
- `file_not_found` — файл не найден (404)

### 4. Модели (Eloquent)

**Расположение:** `src/Models/`

**Структура модели:**
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Factories\HasFactory;

/**
 * Class Example
 *
 * @package App\Models
 *
 * @mixin Model
 *
 * @property int $id
 * @property int $user_id
 * @property string $name
 * @property string $status
 * @property bool $is_active
 * @property array|null $metadata
 * @property Carbon $created_at
 * @property Carbon $updated_at
 * 
 * @property-read User $user
 * @property-read Collection|Item[] $items
 * 
 * @method static Example|null find(int $id)
 * @method static Example findOrFail(int $id)
 * @method static Builder|self where(string $column, mixed $operator = null, mixed $value = null)
 * @method static Builder|self whereIn(string $column, array $values)
 */
class Example extends Model
{
    use HasFactory;

    protected $table = 'examples';

    protected $fillable = [
        'user_id',
        'name',
        'status',
        'is_active',
        'metadata',
    ];

    protected $hidden = [
        'password_hash',
        'secret_key',
    ];

    protected $casts = [
        'is_active' => 'boolean',
        'metadata' => 'array',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    /**
     * Связь: принадлежит пользователю
     * @return BelongsTo<User, Example>
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Связь: имеет много элементов
     * @return HasMany<Item>
     */
    public function items(): HasMany
    {
        return $this->hasMany(Item::class);
    }

    /**
     * Связь: многие ко многим через pivot таблицу
     * @return BelongsToMany<Tag>
     */
    public function tags(): BelongsToMany
    {
        return $this->belongsToMany(Tag::class, 'example_tags')
                    ->withPivot('enabled')
                    ->withTimestamps();
    }

    /**
     * Активные элементы (scope-подобный метод)
     * @return HasMany<Item>
     */
    public function activeItems(): HasMany
    {
        return $this->items()->where('status', 'active');
    }

    /**
     * Проверяет, активен ли элемент
     */
    public function isActive(): bool
    {
        return $this->status === 'active' && $this->is_active;
    }

    /**
     * Получить полное имя (пример аксессора)
     */
    public function getFullName(): string
    {
        return "{$this->name} (ID: {$this->id})";
    }
}
```

**Правила моделей:**
- Полный PHPDoc с `@property`, `@property-read`, `@method`
- Добавлять `@mixin Model` для автодополнения IDE
- Явно указывать `$table` если отличается от конвенции
- Использовать `$fillable` для массового присваивания (НЕ `$guarded`)
- Использовать `$hidden` для скрытия чувствительных данных (пароли, токены)
- Использовать `$casts` для приведения типов (boolean, array, datetime)
- Типизировать возвращаемые значения связей: `HasMany<Model>`, `BelongsTo<Model, Self>`
- Комментарии к методам на русском языке
- Бизнес-методы модели: `isActive()`, `hasSubscription()`, `getFullName()`

### 5. Сервисы

**Расположение:** `src/Services/`

**Структура сервиса:**
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\User;
use App\Models\UserSubscription;
use Psr\Container\ContainerExceptionInterface;
use Psr\Container\ContainerInterface;
use Psr\Container\NotFoundExceptionInterface;
use Illuminate\Database\Eloquent\Collection;
use Exception;

class SubscriptionService
{
    protected ContainerInterface $container;
    protected TelegramService $telegramService;
    protected LogService $logService;

    /**
     * @throws ContainerExceptionInterface
     * @throws NotFoundExceptionInterface
     */
    public function __construct(ContainerInterface $container)
    {
        $this->container = $container;
        $this->telegramService = $container->get(TelegramService::class);
        $this->logService = $container->get(LogService::class);
    }

    /**
     * Получает активные подписки пользователя
     * 
     * @param int $userId ID пользователя
     * @return Collection<UserSubscription> Коллекция подписок
     */
    public function getUserActiveSubscriptions(int $userId): Collection
    {
        return UserSubscription::where('user_id', $userId)
            ->where('status', 'active')
            ->with(['tariff', 'category', 'location'])
            ->get();
    }

    /**
     * Создаёт новую подписку
     * 
     * @param int $userId ID пользователя
     * @param array $data Данные подписки
     * @return UserSubscription Созданная подписка
     * @throws Exception При ошибке создания
     */
    public function createSubscription(int $userId, array $data): UserSubscription
    {
        $user = User::findOrFail($userId);
        
        // Проверяем, нет ли уже активной подписки
        if ($user->hasActiveSubscription($data['category_id'], $data['location_id'])) {
            throw new Exception('У вас уже есть активная подписка на эту категорию и локацию');
        }
        
        // Создаём подписку
        $subscription = $user->requestSubscription(
            $data['tariff_id'],
            $data['category_id'],
            $data['location_id']
        );
        
        // Отправляем уведомление
        $this->telegramService->notifySubscriptionCreated($user, $subscription);
        
        // Логируем
        $this->logService->info('Создана подписка', [
            'user_id' => $userId,
            'subscription_id' => $subscription->id,
        ]);
        
        return $subscription;
    }
}
```

**Правила сервисов:**
- Сервисы содержат ВСЮ бизнес-логику (контроллеры только валидируют и делегируют)
- Инжектируются через DI контейнер в конструкторе
- ОБЯЗАТЕЛЬНО регистрировать в `bootstrap/container.php`
- Использовать другие сервисы через DI (не создавать напрямую)
- PHPDoc с описанием параметров и возвращаемых значений
- Логировать важные операции через LogService
- Выбрасывать исключения с понятными сообщениями

**Регистрация в container.php:**
```php
// bootstrap/container.php
SubscriptionService::class => factory(function (ContainerInterface $c) {
    return new SubscriptionService($c);
}),
```

### 6. Middleware

**Расположение:** `src/Middleware/`

**Структура middleware:**
```php
<?php

declare(strict_types=1);

namespace App\Middleware;

use App\Services\JwtService;
use App\Traits\ResponseTrait;
use Psr\Container\ContainerInterface;
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface as RequestHandler;
use Slim\Psr7\Response as SlimResponse;

class AuthMiddleware implements MiddlewareInterface
{
    use ResponseTrait;

    private JwtService $jwtService;

    public function __construct(ContainerInterface $container)
    {
        $this->jwtService = $container->get(JwtService::class);
    }

    public function process(Request $request, RequestHandler $handler): Response
    {
        // 1. Получаем токен из заголовка
        $authHeader = $request->getHeaderLine('Authorization');
        
        if (empty($authHeader) || !str_starts_with($authHeader, 'Bearer ')) {
            return $this->respondWithError(
                new SlimResponse(),
                'Токен авторизации не предоставлен',
                'token_not_found',
                401
            );
        }
        
        $token = substr($authHeader, 7);
        
        // 2. Валидируем токен
        try {
            $payload = $this->jwtService->validateAccessToken($token);
        } catch (\Exception $e) {
            return $this->respondWithError(
                new SlimResponse(),
                $e->getMessage(),
                'invalid_token',
                401
            );
        }
        
        // 3. Добавляем данные пользователя в request
        $request = $request
            ->withAttribute('userId', $payload->user_id)
            ->withAttribute('userRole', $payload->role ?? 'user')
            ->withAttribute('deviceType', $payload->device_type ?? 'web');
        
        // 4. Передаём дальше
        return $handler->handle($request);
    }
}
```

**Существующие middleware:**
- `AuthMiddleware` — проверка JWT токена, установка userId/userRole в request
- `CorsMiddleware` — CORS заголовки для кросс-доменных запросов
- `JsonBodyParserMiddleware` — парсинг JSON тела запроса

### 7. Маршруты

**Расположение:** `routes/routes.php`

**Структура маршрутов:**
```php
<?php

use App\Controllers\AuthController;
use App\Controllers\UserController;
use App\Controllers\SubscriptionController;
use App\Middleware\AuthMiddleware;
use Slim\App;
use Slim\Routing\RouteCollectorProxy;

return function (App $app) {
    $container = $app->getContainer();
    
    // API Routes v1
    $app->group('/api/v1', function (RouteCollectorProxy $group) use ($container) {

        /** Публичные маршруты аутентификации */
        $group->group('/auth', function (RouteCollectorProxy $group) use ($container) {
            $group->post('/telegram', [TelegramAuthController::class, 'authenticate']);
            $group->post('/login', [AuthController::class, 'login']);
            $group->get('/refresh', [AuthController::class, 'refresh']);
            
            // Защищённые auth маршруты
            $group->post('/telegram/rebind', [TelegramAuthController::class, 'rebindTelegram'])
                ->add(new AuthMiddleware($container));
            $group->get('/logout', [AuthController::class, 'logout'])
                ->add(new AuthMiddleware($container));
        });

        /** Публичные маршруты конфигурации */
        $group->group('/config', function (RouteCollectorProxy $group) {
            $group->get('/telegram-bot-username', [TelegramAuthController::class, 'getBotUsername']);
        });

        /** Защищённые маршруты пользователя */
        $group->group('/me', function (RouteCollectorProxy $group) {
            $group->get('/settings', [UserController::class, 'getSettings']);
            $group->put('/settings', [UserController::class, 'updateSettings']);
            $group->get('/info', [UserController::class, 'getUserInfo']);
            $group->put('/auto-call', [UserController::class, 'updateAutoCall']);
            $group->get('/app-login', [UserController::class, 'getAppLogin']);
            $group->post('/generate-password', [UserController::class, 'generatePassword']);
        })->add(new AuthMiddleware($container));

        /** Защищённые маршруты подписок */
        $group->group('/subscriptions', function (RouteCollectorProxy $group) {
            $group->get('', [SubscriptionController::class, 'getUserSubscriptions']);
            $group->post('', [SubscriptionController::class, 'requestSubscription']);
            $group->get('/all', [SubscriptionController::class, 'getAllUserSubscriptions']);
        })->add(new AuthMiddleware($container));

        /** Административные маршруты (проверка роли в контроллере) */
        $group->group('/admin/subscriptions', function (RouteCollectorProxy $group) {
            $group->post('/activate', [AdminSubscriptionController::class, 'activateSubscription']);
            $group->post('/extend', [AdminSubscriptionController::class, 'extendSubscription']);
            $group->post('/cancel', [AdminSubscriptionController::class, 'cancelSubscription']);
        })->add(new AuthMiddleware($container));

    });
};
```

**Правила маршрутов:**
- ВСЕ API маршруты под `/api/v1/`
- Группировать маршруты по доменам (`/auth`, `/me`, `/subscriptions`)
- `AuthMiddleware` добавлять к защищённым группам через `->add()`
- Использовать regex для параметров: `{id:[0-9]+}`, `{subscription_id:[0-9]+}`
- Комментировать группы маршрутов
- HTTP методы: GET (чтение), POST (создание), PUT (обновление), DELETE (удаление)

### 8. Миграции

**Расположение:** `db/migrations/`

**Скрипт запуска:** `db/migrations/run.php`

---

## Система миграций

### Именование файлов миграций

**Формат:** `YYYYMMDDHHMMSS_description.php`

| Паттерн | Описание | Пример |
|---------|----------|--------|
| `create_*_table` | Создание новой таблицы | `20240101000001_create_users_table.php` |
| `add_*_to_*` | Добавление колонки в таблицу | `20240522000001_add_telegram_bot_blocked_to_users.php` |
| `update_*_structure` | Изменение структуры таблицы | `20240915000001_update_tariffs_structure.php` |
| `fill_*` | Заполнение данными | `20240801000001_fill_location_coordinates.php` |
| `fix_*` | Исправление проблем | `20240920000001_fix_subscription_unique_constraint.php` |
| `remove_*_from_*` | Удаление колонок | `20260125000002_remove_promoted_fields_from_listings.php` |

### Типы миграций

#### 1. Создание новой таблицы

```php
<?php

use Illuminate\Database\Capsule\Manager;

class CreateExamplesTable
{
    /**
     * Имя таблицы для проверки существования
     */
    public function getTableName(): string
    {
        return 'examples';
    }

    public function up()
    {
        Manager::schema()->create('examples', function ($table) {
            // Первичный ключ
            $table->increments('id');
            
            // Внешние ключи
            $table->unsignedInteger('user_id');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            
            $table->unsignedInteger('category_id');
            $table->foreign('category_id')->references('id')->on('categories')->onDelete('cascade');
            
            // Строковые поля
            $table->string('name', 255);
            $table->string('status', 50)->default('active');
            $table->text('description')->nullable();
            
            // Числовые поля
            $table->decimal('price', 10, 2)->nullable();
            $table->unsignedSmallInteger('quantity')->default(0);
            
            // Булевы поля
            $table->boolean('is_active')->default(true);
            $table->boolean('is_enabled')->default(true);
            
            // JSON поля
            $table->json('metadata')->nullable();
            $table->json('bounds')->nullable();
            
            // Координаты
            $table->decimal('lat', 10, 8)->nullable();
            $table->decimal('lng', 11, 8)->nullable();
            
            // Даты
            $table->timestamp('start_date')->nullable();
            $table->timestamp('end_date')->nullable();
            $table->timestamps();
            
            // Уникальные индексы
            $table->unique(['user_id', 'category_id', 'status'], 'unique_user_category_status');
            
            // Обычные индексы для частых запросов
            $table->index(['status', 'created_at']);
            $table->index(['is_active']);
            $table->index(['category_id', 'created_at']);
        });
    }

    public function down()
    {
        Manager::schema()->drop('examples');
    }
}
```

#### 2. Добавление колонки в существующую таблицу

```php
<?php

use Illuminate\Database\Capsule\Manager;

class AddNewFieldToUsers
{
    public function getTableName(): string
    {
        return 'users';
    }

    /**
     * ВАЖНО: Указывает, что миграция модифицирует существующую таблицу
     * и должна выполняться, даже если таблица уже существует
     */
    public function modifiesExistingTable(): bool
    {
        return true;
    }

    public function up()
    {
        Manager::schema()->table('users', function ($table) {
            // Добавляем колонку после определённого поля
            $table->boolean('telegram_bot_blocked')->default(false)->after('telegram_id');
            
            // Или в конец таблицы
            $table->boolean('app_connected')->default(false);
            $table->timestamp('app_last_ping_at')->nullable();
        });
    }

    public function down()
    {
        Manager::schema()->table('users', function ($table) {
            $table->dropColumn('telegram_bot_blocked');
            $table->dropColumn('app_connected');
            $table->dropColumn('app_last_ping_at');
        });
    }
}
```

#### 3. Миграция с PostGIS полями

```php
<?php

use Illuminate\Database\Capsule\Manager;

class AddPostgisFieldsToLocations
{
    public function getTableName(): string
    {
        return 'locations';
    }

    public function modifiesExistingTable(): bool
    {
        return true;
    }

    public function up()
    {
        // 1. Включаем расширение PostGIS
        $this->enablePostGIS();
        
        // 2. Добавляем PostGIS поля через raw SQL
        if (!$this->checkIfColumnExists('locations', 'center_point')) {
            Manager::statement('ALTER TABLE locations ADD COLUMN center_point GEOMETRY(Point, 4326)');
            Manager::statement('ALTER TABLE locations ADD COLUMN bounds_polygon GEOMETRY(Polygon, 4326)');
            
            // 3. Создаём GIST индексы для геопространственных запросов
            Manager::statement('CREATE INDEX idx_locations_center_point ON locations USING GIST(center_point)');
            Manager::statement('CREATE INDEX idx_locations_bounds_polygon ON locations USING GIST(bounds_polygon)');
        }
    }

    public function down()
    {
        if ($this->checkIfColumnExists('locations', 'center_point')) {
            Manager::statement('DROP INDEX IF EXISTS idx_locations_center_point');
            Manager::statement('DROP INDEX IF EXISTS idx_locations_bounds_polygon');
            Manager::statement('ALTER TABLE locations DROP COLUMN IF EXISTS center_point');
            Manager::statement('ALTER TABLE locations DROP COLUMN IF EXISTS bounds_polygon');
        }
    }
    
    private function enablePostGIS()
    {
        $result = Manager::select("SELECT extname FROM pg_extension WHERE extname = 'postgis'");
        if (empty($result)) {
            Manager::statement('CREATE EXTENSION IF NOT EXISTS postgis');
            Manager::statement('CREATE EXTENSION IF NOT EXISTS postgis_topology');
        }
    }
    
    private function checkIfColumnExists(string $table, string $column): bool
    {
        $result = Manager::select("
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = ? AND column_name = ?
        ", [$table, $column]);
        return !empty($result);
    }
}
```

#### 4. Миграция с заполнением данных (seed)

```php
<?php

use Illuminate\Database\Capsule\Manager;

class FillCategoriesTable
{
    public function getTableName(): string
    {
        return 'categories';
    }

    public function modifiesExistingTable(): bool
    {
        return true;
    }

    public function up()
    {
        // Начальные данные для справочника
        $categories = [
            ['name' => 'Аренда жилая (Квартиры)'],
            ['name' => 'Аренда (Коммерческая недвижимость)'],
            ['name' => 'Продажа жилая (Квартиры)'],
            ['name' => 'Продажа (Коммерческая недвижимость)'],
        ];
        
        foreach ($categories as $category) {
            // Используем upsert для идемпотентности
            Manager::table('categories')->upsert(
                array_merge($category, [
                    'created_at' => date('Y-m-d H:i:s'),
                    'updated_at' => date('Y-m-d H:i:s'),
                ]),
                ['name'],  // Уникальный ключ для проверки
                ['updated_at']  // Поля для обновления если запись существует
            );
        }
    }

    public function down()
    {
        // Откат не требуется для seed данных
    }
}
```

#### 5. Миграция с обновлением PostGIS данных

```php
<?php

use Illuminate\Database\Capsule\Manager;

class UpdateLocationsWithCoordinates
{
    public function getTableName(): string
    {
        return 'locations';
    }

    public function modifiesExistingTable(): bool
    {
        return true;
    }

    public function up()
    {
        $locations = Manager::table('locations')->get();
        
        foreach ($locations as $location) {
            if (!isset($location->center_lat) || !isset($location->bounds)) {
                continue;
            }
            
            $bounds = json_decode($location->bounds, true);
            if (!$bounds) continue;
            
            // Создаём WKT для полигона границ
            $wktPolygon = sprintf(
                'POLYGON((%f %f, %f %f, %f %f, %f %f, %f %f))',
                $bounds['west'], $bounds['south'],
                $bounds['east'], $bounds['south'],
                $bounds['east'], $bounds['north'],
                $bounds['west'], $bounds['north'],
                $bounds['west'], $bounds['south']
            );
            
            // Обновляем PostGIS поля
            Manager::statement(
                "UPDATE locations SET 
                center_point = ST_SetSRID(ST_MakePoint(?, ?), 4326),
                bounds_polygon = ST_SetSRID(ST_GeomFromText(?), 4326)
                WHERE id = ?",
                [
                    $location->center_lng,  // longitude первым!
                    $location->center_lat,
                    $wktPolygon,
                    $location->id
                ]
            );
        }
    }

    public function down()
    {
        // Откат: обнуляем PostGIS поля
        Manager::statement("UPDATE locations SET center_point = NULL, bounds_polygon = NULL");
    }
}
```

---

### Как работает run.php

Скрипт `db/migrations/run.php` выполняет миграции в следующем порядке:

1. **Сканирует директорию** — находит все `.php` файлы кроме `run.php`
2. **Сортирует по имени** — миграции выполняются в хронологическом порядке
3. **Преобразует имя файла в класс** — `create_users_table` → `CreateUsersTable`
4. **Проверяет существование таблицы** — вызывает `getTableName()`
5. **Проверяет флаг модификации** — если `modifiesExistingTable()` возвращает `true`, миграция выполняется даже для существующей таблицы
6. **Выполняет миграцию** — вызывает метод `up()`

### Обязательные методы класса миграции

| Метод | Обязательный | Описание |
|-------|--------------|----------|
| `getTableName(): string` | ✅ Да | Возвращает имя таблицы для проверки существования |
| `up()` | ✅ Да | Применяет миграцию |
| `down()` | ⚠️ Рекомендуется | Откатывает миграцию |
| `modifiesExistingTable(): bool` | ❌ Нет | Возвращает `true` если миграция изменяет существующую таблицу |

### Запуск миграций

```bash
# Через Makefile
make migrate

# Напрямую через Docker
docker exec -it slim_php-cli php db/migrations/run.php

# Из контейнера
php db/migrations/run.php
```

### Типы данных колонок

| Метод | PostgreSQL тип | Описание |
|-------|----------------|----------|
| `$table->increments('id')` | SERIAL | Автоинкремент PK |
| `$table->unsignedInteger('user_id')` | INTEGER | Для FK |
| `$table->string('name', 255)` | VARCHAR(255) | Строка |
| `$table->text('description')` | TEXT | Длинный текст |
| `$table->boolean('is_active')` | BOOLEAN | true/false |
| `$table->decimal('price', 10, 2)` | DECIMAL(10,2) | Деньги |
| `$table->unsignedSmallInteger('floor')` | SMALLINT | Малые числа |
| `$table->json('metadata')` | JSON | JSON данные |
| `$table->timestamp('start_date')` | TIMESTAMP | Дата-время |
| `$table->timestamps()` | created_at, updated_at | Метки времени |

### PostGIS типы данных

```sql
-- Точка (широта, долгота)
GEOMETRY(Point, 4326)

-- Полигон (область на карте)
GEOMETRY(Polygon, 4326)

-- SRID 4326 = WGS84 (стандартная система координат GPS)
```

### Индексы

```php
// Обычный индекс для ускорения поиска
$table->index(['status', 'created_at']);

// Уникальный индекс (запрещает дубликаты)
$table->unique(['user_id', 'category_id', 'status'], 'unique_name');

// GIST индекс для PostGIS (через raw SQL)
Manager::statement('CREATE INDEX idx_name ON table USING GIST(geometry_column)');
```

### Внешние ключи

```php
// Простой FK
$table->foreign('user_id')->references('id')->on('users');

// FK с каскадным удалением
$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

// FK с SET NULL при удалении
$table->foreign('city_id')->references('id')->on('cities')->onDelete('set null');
```

### Правила написания миграций

1. **Идемпотентность** — миграция должна безопасно выполняться повторно
2. **Проверка существования** — всегда проверять `hasTable()` или `checkIfColumnExists()`
3. **modifiesExistingTable()** — обязательно для ALTER TABLE миграций
4. **Комментарии** — описывать назначение полей
5. **Индексы** — создавать для полей в WHERE и JOIN
6. **down()** — реализовывать для возможности отката
7. **Порядок** — FK создавать после таблиц, на которые ссылаются

---

## JWT Авторизация

### Структура токенов
- **Access Token:** 1 час (3600 сек), для авторизации API запросов
- **Refresh Token:** 7 дней (604800 сек), для обновления access token, хранится в БД

### Payload токена
```json
{
  "user_id": 123,
  "role": "user",
  "device_type": "web",
  "iat": 1234567890,
  "exp": 1234571490
}
```

### Использование в контроллерах
```php
// Получить ID пользователя (устанавливается AuthMiddleware)
$userId = $request->getAttribute('userId');

// Получить роль пользователя
$userRole = $request->getAttribute('userRole'); // 'user' или 'admin'

// Получить тип устройства
$deviceType = $request->getAttribute('deviceType'); // 'web' или 'mobile'
```

### Проверка прав администратора
```php
/**
 * Проверяет права администратора
 * @return Response|null Ответ с ошибкой или null если доступ разрешён
 */
private function checkAdminAccess(Request $request, Response $response): ?Response
{
    $userRole = $request->getAttribute('userRole', 'user');
    
    if ($userRole !== 'admin') {
        return $this->respondWithError(
            $response,
            'У вас нет доступа к этому ресурсу',
            'access_denied',
            403
        );
    }
    
    return null;
}

// Использование в методе контроллера
public function adminAction(Request $request, Response $response): Response
{
    $accessError = $this->checkAdminAccess($request, $response);
    if ($accessError !== null) {
        return $accessError;
    }
    
    // Продолжаем выполнение для админа
    // ...
}
```

### Поток обновления токена
1. Клиент получает 401 с `token_expired`
2. Клиент отправляет GET `/api/v1/auth/refresh` (refresh token в cookie)
3. Сервер проверяет refresh token в БД
4. Сервер удаляет старый refresh token
5. Сервер создаёт новую пару токенов
6. Возвращает новый access_token, refresh_token в cookie

---

## Логирование

### Использование LogService
```php
// В сервисе или контроллере
$this->logService->error('Ошибка авторизации', [
    'user_id' => $userId,
    'error' => $e->getMessage(),
], 'auth');

$this->logService->warning('Подозрительная активность', [
    'ip' => $request->getServerParams()['REMOTE_ADDR'],
], 'security');

$this->logService->info('Создана подписка', [
    'user_id' => $userId,
    'subscription_id' => $subscription->id,
]);

$this->logService->debug('Отладочная информация', $context);
```

### Уровни логов
- `error` — критические ошибки, требующие внимания
- `warning` — предупреждения, потенциальные проблемы
- `info` — информационные сообщения о важных событиях
- `debug` — отладочная информация (только в dev)

### Файлы логов
- `logs/YYYY-MM-DD.log` — основной лог по дате
- `logs/auth.log` — логи авторизации
- `logs/telegram.log` — логи Telegram API

---

## Работа с Telegram Bot API

### TelegramService
```php
// Инжектируем в сервис
$this->telegramService = $container->get(TelegramService::class);

// Отправка простого сообщения
$this->telegramService->sendMessage($chatId, $message);

// Уведомления о подписках
$this->telegramService->notifyDemoSubscriptionCreated($user, $subscription);
$this->telegramService->notifyPremiumSubscriptionActivated($user, $subscription);
$this->telegramService->notifySubscriptionExpiring($user, $subscription);
$this->telegramService->notifySubscriptionExpired($user, $subscription);

// Отправка пароля
$this->telegramService->sendPasswordNotification($user, $newPassword);

// Уведомление администраторам
$this->telegramService->notifyAdmins("Новая заявка на подписку от {$user->name}");
```

### Обработка ошибок Telegram
```php
try {
    $this->telegramService->sendMessage($chatId, $message);
} catch (GuzzleException $e) {
    // Пользователь заблокировал бота или другая ошибка
    $this->logService->warning('Telegram API error', [
        'chat_id' => $chatId,
        'error' => $e->getMessage(),
    ], 'telegram');
    
    // Помечаем что бот заблокирован
    $user->update(['telegram_bot_blocked' => true]);
}
```

---

## Консольные команды

**Расположение:** `src/Commands/`

**Структура команды:**
```php
<?php

declare(strict_types=1);

namespace App\Commands;

use App\Services\TelegramService;
use App\Models\UserSubscription;
use Carbon\Carbon;

class NotifySubscriptionExpiringCommand
{
    private TelegramService $telegramService;

    public function __construct(TelegramService $telegramService)
    {
        $this->telegramService = $telegramService;
    }

    /**
     * Уведомляет пользователей об истекающих подписках
     */
    public function execute(): void
    {
        $expiringDate = Carbon::now()->addDays(3);
        
        $subscriptions = UserSubscription::where('status', 'active')
            ->whereDate('end_date', $expiringDate->toDateString())
            ->with('user')
            ->get();
        
        foreach ($subscriptions as $subscription) {
            $this->telegramService->notifySubscriptionExpiring(
                $subscription->user,
                $subscription
            );
        }
        
        echo "Отправлено уведомлений: " . $subscriptions->count() . "\n";
    }
}
```

**Запуск команды:**
```bash
docker exec -it slim_php-cli php bin/app.php notify:expiring
```

---

## Docker команды

```bash
# Запуск проекта
make up

# Остановка
make down

# Пересборка контейнеров
make build

# Просмотр логов
make logs

# Запуск миграций
make migrate

# Установка composer зависимостей
make install

# Инициализация проекта с нуля
make init

# Вход в PHP-CLI контейнер
docker exec -it slim_php-cli bash

# Выполнение PHP команды
docker exec -it slim_php-cli php bin/app.php <command>
```

---

## Переменные окружения

**Файл:** `.env` (копировать из `.env.example`)

```bash
# Приложение
APP_NAME="FIRST CALL REST API"
APP_ENV=local                    # local, production
APP_DEBUG=true                   # true только в dev!
APP_URL=https://local.firstcall.com
APP_TIMEZONE=Europe/Moscow

# База данных PostgreSQL
DB_CONNECTION=pgsql
DB_HOST=postgres                 # имя docker контейнера
DB_PORT=5432
DB_DATABASE=slim_api
DB_USERNAME=postgres
DB_PASSWORD=postgres

# JWT токены
JWT_SECRET=your_access_secret_min_32_chars
JWT_REFRESH_SECRET=your_refresh_secret_min_32_chars
JWT_ACCESS_EXPIRATION=3600       # 1 час в секундах
JWT_REFRESH_EXPIRATION=604800    # 7 дней в секундах

# Telegram Bot
TELEGRAM_BOT_TOKEN=123456:ABC-DEF...
TELEGRAM_BOT_USERNAME=FirstCallBot
TELEGRAM_ADMIN_CHAT_ID=123456789

# Frontend URL (для CORS)
FRONTEND_URL=https://local.firstcall.com
```

**ВАЖНО:** Никогда не коммитить `.env` файл! Только `.env.example`

---

## Соглашения по именованию

### Файлы и классы
| Тип | Формат | Пример |
|-----|--------|--------|
| Контроллеры | `{Name}Controller.php` | `UserController.php` |
| Модели | `{Name}.php` (ед. число) | `User.php`, `UserSubscription.php` |
| Сервисы | `{Name}Service.php` | `SubscriptionService.php` |
| Middleware | `{Name}Middleware.php` | `AuthMiddleware.php` |
| Traits | `{Name}Trait.php` | `ResponseTrait.php` |
| Commands | `{Name}Command.php` | `ParseCianCommand.php` |

### Методы
| Слой | Стиль | Примеры |
|------|-------|---------|
| Контроллеры | глаголы | `getSettings`, `updateSettings`, `createSubscription` |
| Модели | описательные | `isActive()`, `hasSubscription()`, `getFullName()` |
| Сервисы | действия | `createSubscription()`, `sendNotification()`, `processPayment()` |
| Валидация | `validate*Data` | `validateSettingsData()`, `validatePhoneStatusData()` |

### Таблицы БД
- Множественное число, snake_case: `users`, `user_subscriptions`, `tariff_prices`
- Pivot таблицы: алфавитный порядок: `user_sources` (не `source_users`)
- Foreign keys: `{table}_id` → `user_id`, `tariff_id`

### Маршруты API
- kebab-case для URL: `/api/v1/location-polygons`, `/api/v1/tariff-info`
- Множественное число для ресурсов: `/subscriptions`, `/users`
- Вложенность для связей: `/subscriptions/{id}/history`

---

## Типичные ошибки и как их избежать

1. **Забыть `declare(strict_types=1);`** — добавлять в КАЖДЫЙ PHP файл

2. **Не оборачивать код в try-catch** — всегда ловить исключения в контроллерах

3. **Писать бизнес-логику в контроллерах** — выносить в сервисы

4. **Забыть зарегистрировать сервис** — добавлять в `bootstrap/container.php`

5. **Отсутствие PHPDoc** — документировать модели и публичные методы

6. **Не валидировать входные данные** — всегда проверять перед использованием

7. **Не использовать ResponseTrait** — единообразные ответы API

8. **Не проверять права доступа** — `checkAdminAccess()` для админ-эндпоинтов

9. **Мутировать модели без сохранения** — не забывать `$model->save()`

10. **Не обновлять документацию** — синхронизировать openapi.yaml и DATABASE.md

11. **Хардкодить конфигурацию** — использовать `.env` и `config/`

12. **Не логировать важные события** — использовать LogService

---

## OpenAPI Документация REST API

### Расположение файлов
- **OpenAPI спецификация**: `docs/api/openapi.yaml`
- **Redoc HTML**: `docs/api/redoc.html`
- **Краткий справочник**: `docs/API-QUICK-REFERENCE.md`

### Запуск документации локально
```bash
cd docs/api && python3 -m http.server 8080
# Открыть: http://localhost:8080/redoc.html
```

---

## Стандарты документирования API

### HTTP коды ответов

| Код | Описание | Когда использовать |
|-----|----------|-------------------|
| `200` | Успешный запрос | GET, PUT, DELETE успешно выполнены |
| `201` | Ресурс создан | POST успешно создал ресурс |
| `400` | Неверный формат запроса | Неправильный JSON, отсутствуют/пустые обязательные поля, неверный тип данных |
| `401` | Не авторизован | Отсутствует токен, токен истёк, невалидный токен |
| `403` | Доступ запрещён | Нет прав (не админ), подписка истекла |
| `404` | Ресурс не найден | Пользователь/подписка/локация не найдены |
| `409` | Конфликт | Ресурс уже существует (например, Telegram уже привязан) |
| `422` | Ошибка валидации | Нарушение бизнес-правил, неверный формат данных, ошибка сохранения |
| `500` | Внутренняя ошибка | Необработанное исключение на сервере |

### Машинночитаемые коды ошибок (поле `error`)

**Ошибки авторизации (401):**
```yaml
- token_not_found      # Токен не найден в заголовке/cookie
- token_expired        # Срок действия токена истёк
- invalid_token        # Невалидный токен (неверная подпись)
- invalid_token_type   # Неверный тип токена (access вместо refresh)
- invalid_credentials  # Неверный логин или пароль
```

**Ошибки доступа (403):**
```yaml
- access_denied        # Нет прав доступа
- subscription_expired # Подписка истекла
```

**Ошибки валидации (400, 422):**
```yaml
- validation_error     # Ошибка валидации входных данных
- operation_failed     # Операция не выполнена (например, подписка уже существует)
- save_failed          # Не удалось сохранить данные
- invalid_telegram_data # Невалидные данные Telegram
```

**Ошибки ресурсов (404, 409):**
```yaml
- not_found            # Ресурс не найден
- user_not_found       # Пользователь не найден
- telegram_already_bound # Telegram уже привязан к другому пользователю
```

**Внутренние ошибки (500):**
```yaml
- internal_error       # Внутренняя ошибка сервера
```

### Формат JSON ответов

**Успешный ответ:**
```json
{
  "code": 200,
  "status": "success",
  "message": "Настройки успешно обновлены",
  "data": {
    "settings": { ... },
    "sources": [ ... ]
  }
}
```

**Ответ с ошибкой:**
```json
{
  "code": 400,
  "status": "error",
  "message": "Неверный формат запроса. Отсутствует обязательное поле status",
  "error": "validation_error"
}
```

### Тексты сообщений об ошибках

**Формат сообщений валидации:**
```
"Неверный формат запроса. {детали}"
"Неверный формат запроса. Отсутствует обязательное поле {field}"
"Неверный формат запроса. Поле {field} должно быть {type}"
"Неверный формат запроса. Данные должны быть переданы в формате JSON"
```

**Формат сообщений токенов:**
```
"Access token not found"
"Access token expired"
"Invalid access token"
"Refresh token not found"
"Refresh token expired"
"Invalid token type"
```

**Формат сообщений ресурсов:**
```
"Пользователь не найден"
"Подписка не найдена"
"Локация не найдена"
"Указанный тариф не найден"
"Указанная локация не найдена"
```

**Формат сообщений бизнес-логики:**
```
"Вы уже использовали демо-тариф ранее"
"Не удалось создать подписки. Возможно, они уже существуют"
"Этот Telegram аккаунт уже привязан к другому пользователю"
"Доступ запрещен: подписка истекла"
```

---

## Структура OpenAPI документации

### Теги (группировка эндпоинтов)
```yaml
tags:
  - name: Аутентификация
    description: Методы для авторизации и управления токенами
  - name: Пользователь
    description: Методы для работы с данными пользователя
  - name: Подписки
    description: Методы для управления подписками
  - name: Локации
    description: Методы для управления локациями и полигонами
  - name: Конфигурация
    description: Методы для получения конфигурационных данных
  - name: Администрирование
    description: Методы для администраторов системы
  - name: Billing
    description: Методы для управления биллингом подписок
```

### Схема авторизации
```yaml
components:
  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: JWT токен доступа
```

### Базовая схема ошибки
```yaml
components:
  schemas:
    Error:
      type: object
      properties:
        code:
          type: integer
          description: HTTP код ошибки
          example: 400
        status:
          type: string
          description: Статус ответа
          example: error
        message:
          type: string
          description: Сообщение об ошибке (человекочитаемое)
          example: Неверный формат данных
        error:
          type: string
          description: Код ошибки для программной обработки
          enum:
            - token_not_found
            - token_expired
            - invalid_token
            - invalid_token_type
            - invalid_credentials
            - subscription_expired
            - validation_error
          example: validation_error
```

---

## Полный пример документирования эндпоинта

```yaml
/api/v1/me/phone-status:
  put:
    summary: Обновить статус телефона
    description: |
      Обновляет статус телефона пользователя (занят/свободен).
      
      Этот статус может использоваться для маршрутизации звонков и отображения
      текущего состояния пользователя в интерфейсе.
    tags:
      - Пользователь
    security:
      - BearerAuth: []
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/PhoneStatus'
    responses:
      '200':
        description: Статус телефона успешно обновлен
        content:
          application/json:
            schema:
              type: object
              properties:
                code:
                  type: integer
                  example: 200
                status:
                  type: string
                  example: success
                message:
                  type: string
                  example: Статус телефона успешно обновлен
      '400':
        description: "Неверный формат запроса"
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Error'
            examples:
              invalid_json:
                value:
                  code: 400
                  status: error
                  message: "Неверный формат запроса. Данные должны быть переданы в формате JSON"
                  error: "validation_error"
              missing_status:
                value:
                  code: 400
                  status: error
                  message: "Неверный формат запроса. Отсутствует обязательное поле status"
                  error: "validation_error"
              invalid_status_type:
                value:
                  code: 400
                  status: error
                  message: "Неверный формат запроса. Поле status должно быть boolean"
                  error: "validation_error"
      '401':
        description: "Ошибка аутентификации"
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Error'
            examples:
              token_not_found:
                value:
                  code: 401
                  status: error
                  message: "Token not found"
                  error: "token_not_found"
              invalid_token:
                value:
                  code: 401
                  status: error
                  message: "Invalid token"
                  error: "invalid_token"
              token_expired:
                value:
                  code: 401
                  status: error
                  message: "Token expired"
                  error: "token_expired"
      '500':
        description: "Внутренняя ошибка сервера"
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Error'
            example:
              code: 500
              status: error
              message: "Внутренняя ошибка сервера"
              error: "internal_error"
```

---

## ОБЯЗАТЕЛЬНОЕ обновление документации

### При изменении REST API

При добавлении, изменении или удалении эндпоинтов API **ВСЕГДА** обновлять:

1. **OpenAPI спецификация** (`docs/api/openapi.yaml`):
   - Добавить/обновить path для эндпоинта
   - Указать `tags` для группировки
   - Написать `summary` (краткое описание) и `description` (подробное)
   - Указать `security: [BearerAuth: []]` если требуется авторизация
   - Описать `requestBody` со схемой и примером
   - Описать ВСЕ возможные `responses` с примерами:
     - `200`/`201` — успешный ответ
     - `400` — ВСЕ варианты ошибок валидации с разными `examples`
     - `401` — ВСЕ варианты ошибок токена (not_found, expired, invalid)
     - `404` — если ресурс может быть не найден
     - `409` — если возможен конфликт
     - `422` — если есть бизнес-валидация
     - `500` — внутренняя ошибка

2. **Краткий справочник** (`docs/API-QUICK-REFERENCE.md`):
   - Добавить эндпоинт в соответствующую секцию
   - Указать метод, URL, краткое описание

### При изменении базы данных

При создании миграций или изменении структуры БД **ВСЕГДА** обновлять:

1. **Документация БД** (`docs/DATABASE.md`):
   - Добавить/обновить описание таблицы
   - Описать новые поля и их типы
   - Обновить связи между таблицами
   - Добавить информацию об индексах

2. **Модели Eloquent**: обновить PHPDoc
   - Добавить `@property` для новых полей
   - Обновить `@property-read` для связей

### Чек-лист перед завершением задачи

- [ ] Обновлен `docs/api/openapi.yaml` с ВСЕМИ вариантами ответов
- [ ] Добавлены `examples` для КАЖДОГО кода ошибки
- [ ] Обновлен `docs/API-QUICK-REFERENCE.md`
- [ ] Обновлен `docs/DATABASE.md` (если менялась БД)
- [ ] Обновлен PHPDoc в моделях (если менялась БД)
- [ ] Проверена актуальность `docs/ARCHITECTURE.md`

---

## Работа с PostGIS

### Геопространственные запросы
```php
use Illuminate\Support\Facades\DB;

// Найти объявления в полигоне пользователя
$listings = DB::select("
    SELECT l.* FROM listings l
    JOIN user_location_polygons ulp 
      ON ST_Contains(ulp.polygon, ST_SetSRID(ST_Point(l.lng, l.lat), 4326))
    WHERE ulp.user_id = ?
", [$userId]);

// Расстояние между точками (в метрах)
$distance = DB::selectOne("
    SELECT ST_Distance(
      ST_SetSRID(ST_Point(?, ?), 4326)::geography,
      ST_SetSRID(ST_Point(?, ?), 4326)::geography
    ) AS distance_meters
", [$lng1, $lat1, $lng2, $lat2]);
```

### Создание полигона
```php
// В миграции или модели
$polygon = "ST_SetSRID(ST_GeomFromGeoJSON(?), 4326)";
$coordinates = json_encode([
    'type' => 'Polygon',
    'coordinates' => [[[lng1, lat1], [lng2, lat2], ...]]
]);
```

---

## Полезные ссылки

- Slim Framework: https://www.slimframework.com/docs/v4/
- Eloquent ORM: https://laravel.com/docs/10.x/eloquent
- PHP-DI: https://php-di.org/doc/
- PSR-7: https://www.php-fig.org/psr/psr-7/
- PSR-15: https://www.php-fig.org/psr/psr-15/
- PostGIS: https://postgis.net/docs/
- Firebase JWT: https://github.com/firebase/php-jwt

